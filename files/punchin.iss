; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define MyAppName "punchin"
#define MyAppVersion "1.5"
#define MyAppPublisher "collegeek"
#define MyAppURL "https://www.collegeek.com/"
#define MyAppExeName "punchin.exe"

[Setup]
; NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{8AC36538-8103-4490-B940-F98F94DC1843}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName={autopf}\autoPunchIn
DisableProgramGroupPage=yes
LicenseFile=F:\Windowcmd\Python apps\Punchin\END USER LICENSE AGREEMENT.md
InfoBeforeFile=F:\Windowcmd\Python apps\Punchin\beforeInstall.txt
InfoAfterFile=F:\Windowcmd\Python apps\Punchin\afterInstall.txt
; Uncomment the following line to run in non administrative install mode (install for current user only.)
;PrivilegesRequired=lowest
OutputBaseFilename=punchinsetup
SetupIconFile=F:\Windowcmd\Python apps\Punchin\favicon.ico
Compression=lzma
SolidCompression=yes
DisableDirPage=no
WizardStyle=modern

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

[Files]
Source: "F:\Windowcmd\Python\punchin\output\{#MyAppExeName}"; DestDir: "{app}"; Flags: ignoreversion
Source: "F:\Windowcmd\Python apps\Punchin\autoPunchIn.xml"; DestDir: "{app}"; Flags: ignoreversion
Source: "F:\Windowcmd\Python apps\Punchin\assets\*"; DestDir: "{app}\assets"; Flags: ignoreversion recursesubdirs createallsubdirs
Source: "F:\Windowcmd\Python\punchin\output\punchin\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs
//Source: "F:\Windowcmd\Python apps\Punchin\7z.exe"; DestDir: "{tmp}"; Flags: deleteafterinstall

; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Icons]
Name: "{autoprograms}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"
Name: "{autodesktop}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon

[Run]
Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent;
//Filename: "{tmp}\7z.exe"; Parameters: "e chromedriver_win32.zip"; AfterInstall: WriteAppPath
//Filename: "schtasks"; Parameters: "/create /XML {app}\autoPunchIn.xml /tn autoPunchIn"; BeforeInstall WriteAppPath

[Icons]
Name: "{group}\My Program"; Filename: "{app}\MyProg.exe"

[UninstallDelete]
Type: files; Name: "{app}\chromedriver.exe"
Type: files; Name: "{app}\key.txt"
Type: files; Name: "{app}\logs.txt"
Type: files; Name: "{app}\logs0.txt"
Type: files; Name: "{app}\logs1.txt"
Type: filesandordirs; Name: "{app}\.wdm"


[Code]
(*
var
  DownloadPage: TDownloadWizardPage;
const
  ChromeAppRegKey = 'Software\Microsoft\Windows\CurrentVersion\App Paths\chrome.exe';

function OnDownloadProgress(const Url, FileName: String; const Progress, ProgressMax: Int64): Boolean;
begin
  if Progress = ProgressMax then
    Log(Format('Successfully downloaded file to {tmp}: %s', [FileName]));
  Result := True;
end;



function IsChromeInstalled: Boolean;
begin
  { check if there's the Chrome app registration entry under the HKCU, or }
  { HKLM root key, return the result }
  Result := RegKeyExists(HKEY_CURRENT_USER, ChromeAppRegKey) or
    RegKeyExists(HKEY_LOCAL_MACHINE, ChromeAppRegKey);
end;

function GetChromeFileName: string;
var
  S: string;
begin
  { initialize returned value to an empty string }
  Result := '';
  { first attempt to read the Chrome app file name from the HKCU root key; }
  { if that fails, try to read the same from HKLM; if any of that succeed, }
  { return the obtained registry value }
  if RegQueryStringValue(HKEY_CURRENT_USER, ChromeAppRegKey, '', S) or
    RegQueryStringValue(HKEY_LOCAL_MACHINE, ChromeAppRegKey, '', S)
  then
    Result := S;
end;

procedure WriteAppPath;
var
  A: AnsiString;
  U: String;
begin
  LoadStringFromFile(ExpandConstant('{app}\autoPunchIn.xml'), A);
  U:=A
  Log(Format('File Data %s',[U]))
  StringChange(U, 'XcomandX', ExpandConstant('{app}\{#MyAppExeName}'));
  StringChange(U, 'XworkingX', ExpandConstant('{app}'));
  Log(Format('File Data %s',[U]))
  A:=U
  SaveStringToFile(ExpandConstant('{app}\autoPunchIn.xml'), A, False);

  if FileCopy(ExpandConstant('{tmp}\chromedriver.exe'), ExpandConstant('{app}\chromedriver.exe'), false) then
  begin
    Log('copied chromedriver')
  end;

end;

function GetChromeVersion(Value: string;Version: Integer): string;
var
  Major: string;
  Minor: string;
  Build: string;
  Revision: string;
begin
  Result := '';
  Major := Copy(Value, 1, Pos('.', Value) - 1);
  Delete(Value, 1, Pos('.', Value));
  Minor := Copy(Value, 1, Pos('.', Value) - 1);
  Delete(Value, 1, Pos('.', Value));
  Build := Copy(Value, 1, Pos('.', Value) - 1);
  Delete(Value, 1, Pos('.', Value));
  Revision := Value;
  case (Version) of
    1 : Result := Format('%s', [Major]);
    2 : Result := Format('%s.%s', [Major, Minor]);
    3 : Result := Format('%s.%s.%s', [Major, Minor, Build]);
  else
      Result := Format('%s.%s.%s.%s', [Major, Minor, Build, Revision]);
  end;
end;


function TryGetFileLine(const FileName: string; Index: Integer; out Line: string): Boolean;
var  
  FileLines: TArrayOfString;
begin
  // the function succeed when the file can be loaded and the count of lines is
  // greater than the requested line index (it is 0 based index, hence the line
  // count must be greater)
  Result := LoadStringsFromFile(FileName, FileLines) and (GetArrayLength(FileLines) > Index);
  // if the above succeeded, return the file line of the requested index to the
  // output parameter
  if Result then
    Line := FileLines[Index];
end;

procedure InitializeWizard;
begin
  
end;

function RobustDownload(
  Url, BaseName, RequiredSHA256OfFile: String): Boolean;
var
  Retry: Boolean;
  Answer: Integer;
  S: String;
  Version: Integer;
begin
  repeat
    try
      DownloadPage.Clear;
      Log(Format('chrome url: %s',[Url]))
      DownloadPage.Add(Url, BaseName, RequiredSHA256OfFile);
      DownloadPage.Download;
      Retry := False;
      Result := True;
    except
      if DownloadPage.AbortedByUser then
      begin
        Log('Aborted by user.')
        Result := False;
        Retry := False;
      end
      else
      begin
        // Make sure the page displays the URL that fails to download
        DownloadPage.Msg2Label.Caption := Url;
        Answer := SuppressibleMsgBox(AddPeriod(GetExceptionMessage),mbCriticalError, MB_ABORTRETRYIGNORE, IDABORT);
        Retry := False;
        Result := False;
      end;
    end;
  until not Retry;
end;

function NextButtonClick(CurPageID: Integer): Boolean;
var 
  S: string;
  Chromeurl: string;
  Version: Integer;
  i: Integer;
begin
  if CurPageID = wpReady then
  begin
    try
      if IsChromeInstalled then
      begin
        Log('chrome installation found')
        if GetVersionNumbersString(GetChromeFileName,S) then
        begin
          Log(Format('chrome version: %s found',[S]))
          Version := StrToInt(GetChromeVersion(S,1));
        end;
      end else
      Log('chrome not found');

      DownloadPage :=
        CreateDownloadPage(
          SetupMessage(msgWizardPreparing), SetupMessage(msgPreparingDesc),
          @OnDownloadProgress);

      DownloadPage.Show;

      //Result := RobustDownload(Format('https://chromedriver.storage.googleapis.com/LATEST_RELEASE_%d',[Version]), 'chromedriver_win32.txt', '');
      
      // retry 10 times downloading other lower versions
      {for i:= 1 to 10 do
       begin
        Result := RobustDownload(Format('https://chromedriver.storage.googleapis.com/LATEST_RELEASE_%d',[Version - i]), 'chromedriver_win32.txt', '');
        if Result then
          break;
      end;
    
      if Result then
      begin
        //if TryGetFileLine(ExpandConstant('{tmp}\chromedriver_win32.txt'),0,S) then
        begin
          S := GetChromeVersion(S,4);
          Result := RobustDownload(Format('https://chromedriver.storage.googleapis.com/%s/chromedriver_win32.zip',[S]), 'chromedriver_win32.zip', '');
        end;
      end;
      }
    finally
      DownloadPage.Hide;
    end;
  end
    else Result := True;
end;
*)



